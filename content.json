{"meta":{"title":"Y-Blog","subtitle":"","description":"记录点滴,热爱分享","author":"yuanyu","url":"https://yuanyu96.github.io","root":"/"},"pages":[{"title":"书单","date":"2021-09-28T08:08:01.685Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"books/index.html","permalink":"https://yuanyu96.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-09-28T10:26:16.820Z","updated":"2021-09-28T10:26:16.820Z","comments":true,"path":"categories/index.html","permalink":"https://yuanyu96.github.io/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-09-28T08:08:01.668Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"/404.html","permalink":"https://yuanyu96.github.io/404.html","excerpt":"","text":""},{"title":"标签","date":"2021-09-28T08:08:01.691Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"tags/index.html","permalink":"https://yuanyu96.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-09-28T09:40:22.003Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"about/index.html","permalink":"https://yuanyu96.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2021-09-28T08:08:01.687Z","updated":"2021-05-31T02:54:50.000Z","comments":true,"path":"links/index.html","permalink":"https://yuanyu96.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-09-28T08:08:01.689Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"repository/index.html","permalink":"https://yuanyu96.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaSe-集合","slug":"JavaSe-集合","date":"2021-10-09T06:34:30.000Z","updated":"2021-10-09T10:22:28.083Z","comments":true,"path":"2021/10/09/JavaSe-集合/","link":"","permalink":"https://yuanyu96.github.io/2021/10/09/JavaSe-%E9%9B%86%E5%90%88/","excerpt":"","text":"数组和集合比较数组不是面向对象的，存在明显的缺陷，集合弥补了数组的缺点，比数组更灵活更实用，而且不同的集合框架类可适用不同场合。如下： 数组能存放基本数据类型和对象，而集合类存放的都是对象，集合类不能存放基本数据类型。数组和集合存放的对象皆为对象的引用地址。 数组容易固定无法动态改变，集合类容量动态改变。 数组无法判断其中实际存有多少元素，length只告诉了数组的容量，而集合的size()可以确切知道元素的个数 集合有多种实现方式和不同适用场合，不像数组仅采用顺序表方式 集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性即可实现各种复杂操作，大大提高了软件的开发效率 JAVA 集合框架 从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。 集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容： 接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。 除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。 Java 集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于java.util包中 Collection 接口的接口 对象的集合（单列集合）├——-List 接口：元素按进入先后有序保存，可重复│—————-├ LinkedList 接口实现类， 链表， 插入删除， 没有同步， 线程不安全│—————-├ ArrayList 接口实现类， 数组， 随机访问， 没有同步， 线程不安全│—————-└ Vector 接口实现类 数组， 同步， 线程安全│ ———————-└ Stack 是Vector类的实现类└——-Set 接口： 仅接收一次，不可重复，并做内部排序├—————-└HashSet 使用hash表（数组）存储元素│————————└ LinkedHashSet 链表维护元素的插入次序└ —————-TreeSet 底层实现为二叉树，元素排好序 Map 接口 键值对的集合 （双列集合）├———Hashtable 接口实现类， 同步， 线程安全├———HashMap 接口实现类 ，没有同步， 线程不安全-│—————–├ LinkedHashMap 双向链表和哈希表实现│—————–└ WeakHashMap├ ——–TreeMap 红黑树对所有的key进行排序└———IdentifyHashMap 一.Collection接口 collection的子接口List:接口—实现类： LinkedList,Vector,ArrayList Set:接口 —实现类： HashSet、LinkedHashSet ​ Set的子接口SortedSet接口—实现类：TreeSet 1、List集合 有序列表，允许存放重复的元素；实现类： ArrayList：数组实现，查询快，增删慢，轻量级；(线程不安全) LinkedList：双向链表实现，增删快，查询慢 (线程不安全) Vector：数组实现，重量级 (线程安全、使用少) ArrayList底层是Object数组，所以ArrayList具有数组的查询速度快的优点以及增删速度慢的缺点。 而在LinkedList的底层是一种双向循环链表。在此链表上每一个数据节点都由三部分组成：前指针（指向前面的节点的位置），数据，后指针（指向后面的节点的位置）。最后一个节点的后指针指向第一个节点的前指针，形成一个循环。 双向循环链表的查询效率低但是增删效率高。 ArrayList和LinkedList在用法上没有区别，但是在功能上还是有区别的。 面试点1:ArrayList扩容机制实现机制：ArrayList.ensureCapacity(int minCapacity)首先得到当前elementData 属性的长度oldCapacity。然后通过判断oldCapacity和minCapacity参数谁大来决定是否需要扩容, 如果minCapacity大于 oldCapacity，那么我们就对当前的List对象进行扩容。 扩容的的策略为：取(oldCapacity * 3)/2 + 1和minCapacity之间更大的那个。然后使用数组拷 贝的方法，把以前存放的数据转移到新的数组对象中 如果minCapacity不大于oldCapacity那么就不进行扩容。 面试点2：安全删除ArrayList元素Java中循环遍历元素，一般有for循环遍历，foreach循环遍历，iterator遍历。 先定义一个List对象 1234List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;1&quot;);list.add(&quot;2&quot;);list.add(&quot;3&quot;); 一：普通For循环遍历删除 12345678910111213 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(i + &quot;:&quot; + list.get(i)); String s = list.get(i); if (&quot;1&quot;.equals(s)) &#123; list.remove(s); // i--; &#125; if(&quot;2&quot;.equals(s))&#123; list.remove(s); &#125; &#125; System.out.println(list);&#125; 输出结果为 1230:11:3[2, 3] 这种删除方法明显有问题，遗漏了被删除元素后的一个元素。这种情况下，如果被删除元素切好是List中最后一个元素，则输出结果恰好正常。解决方法:遗漏元素是因为删除元素后，List的size已经减1，但i不变，则i位置元素等于被跳过，不在循环中处理。若if代码块中调用remove函数后，加上i–，则能避免这种错误。 二：Iterator遍历 123456789Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; String str = iterator.next(); System.out.println(str); if(&quot;2&quot;.equals(str)) &#123; iterator.remove(); &#125;&#125;System.out.println(list); 输出结果为 1234123[1, 3] 结论:这是最安全的遍历中删除元素方法。借用了Iterator，删除元素用的也是Iterator的remove方法，而不是List中的 三：foreach循环遍历 123456for (String s : list) &#123; System.out.println(s); if (&quot;2&quot;.equals(s)) &#123; list.remove(s); &#125;&#125; 现象：删除元素2：正常输出 1231 2 [1, 3] 删除元素1或3：报错 123java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909) at java.util.ArrayList$Itr.next(ArrayList.java:859) foreach实质上也是使用Iterator进行遍历。不同的地方在于，一个使用Iterator的删除方法，一个使用List的删除方法。问题出在 list.remove(s); 具体原因： 我们查看一下ArrayList的报错相关代码。代码如下： 12345678910111213141516171819202122232425public boolean hasNext() &#123; return cursor != size;&#125;public E next() &#123; checkForComodification();//859行 int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i];&#125;final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();//909行&#125;public boolean remove(Object o) &#123; ··· fastRemove(index); ···&#125;private void fastRemove(int index) &#123; modCount++; ···&#125; 其中size和modCount为ArrayList属性，cursor和expectedModCount为ArrayList.Itr属性。 1234size: List长度modCount: List在结构上被修改的次数cursor: Itr中下一个被返回的元素的下标expectedModCount: 属于ArrayList.Itr，与modCount类似，初始化值等于modCount值。 报错是因为remove方法改变了modCount，导致next方法时checkForComodification检查不通过，抛出异常。 移除2时正常：因为2刚好是倒数第二个元素，移除后size-1，在hasNext方法中已结束循环，不在调用next方法。虽然不报错，但会使最后一个元素被跳过，没有进入循环。 移除1或3失败略有不同：remove(3)后，size减1，cursor已经比size大1，但由于hasNext方法是 cursor!=size，还是会进入循环，在next方法中才会报错。如果hasNext方法是 cursor&gt;size ，移除3的情形会类似于移除2(不报错，直接退出进入循环)。 结论：集合中遍历移除元素保险起见都是使用Iterator，Java8中的删除方法removeIf，如下，其实也是使用Iterator。 1list.removeIf(e-&gt;e.equals(&quot;2&quot;)); LinkedListLinkedList是采用双向循环链表实现的。 利用LinkedList实现栈(stack)、队列(queue)、双向队列(double-ended queue )。 它具有方法addFirst()、addLast()、getFirst()、getLast()、removeFirst()、removeLast()等。 经常用在增删操作较多而查询操作很少的情况下： 队列和堆栈。 Vector（与ArrayList相似，区别是Vector是重量级的组件，使用使消耗的资源比较多。） 结论：在考虑并发的情况下用Vector（保证线程的安全）。 在不考虑并发的情况下用ArrayList（不能保证线程的安全）。 Vector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用 2、Set集合HashSetHashSet实现Set接口，底层由HashMap(后面讲解)来实现，为哈希表结构，新增元素相当于HashMap的key，value默认为一个固定的Object。在我看来，HashSet相当于一个阉割版的HashMap 特点： 不允许出现重复因素； 允许插入Null值； 元素无序（添加顺序和遍历顺序不一致）； 线程不安全，若2个线程同时操作HashSet，必须通过代码实现同步； 由于Set集合中并没有角标的概念，所以并没有像List一样提供get（）方法。当获取HashSet中某个元素时，只能通过遍历集合的方式进行equals()比较来实现 TreeSet从名字上可以看出，此集合的实现和树结构有关。与HashSet集合类似，TreeSet也是基于Map来实现，具体实现TreeMap(后面讲解)，其底层结构为红黑树（特殊的二叉查找树）； 与HashSet不同的是，TreeSet具有排序功能，分为自然排序(123456)和自定义排序两类，默认是自然排序；在程序中，我们可以按照任意顺序将元素插入到集合中，等到遍历时TreeSet会按照一定顺序输出–倒序或者升序 面试点1：自然排序和定制排序1.自然排序在讲自然排序之前，要先讲一下Comparable接口。 Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法,该方法返回一个整数值，实现该接口的类必须实现该方法，实现了该接口的类的对象就可以比较大小了。当一个对象调用该方法与另一个对象比较时，例如obj1.compareTo(obj2),如果该方法返回0，则表明两个对象相等；如果该方法返回一个整数，则表明obj1大于obj2;如果该方法返回一个负整数，则表明oj1小于obj2。 TreeSet会调用集合中元素所属类的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排列，即把通过compareTo(Object obj)方法比较后比较大的的往后排。这种方式就是自然排序。 Java的一些常用类已经实现了Comparable接口，并提供了比较大小的标准。例如，String按字符串的UNICODE值进行比较，Integer等所有数值类型对应的包装类按它们的数值大小进行比较。 除了这些已经实现Comparable接口类之外，如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，否则就会出现异常。 注意：TreeSet中只能添加同一种类型的对象，否则无法比较，会出现异常。 2.定制排序TreeSet的自然排序是根据集合元素中compareTo(Object obj)比较的大小，以升序排列。而定制排序是通过Comparator接口的帮助。该接口包含一个int compare(T o1,T o2)方法，该方法用于比较o1,o2的大小：如果该方法返回正整数，则表明o1大于o2；如果该方法返回0，则表明o1等于o2;如果该方法返回负整数，则表明o1小于o2。 如果要实现定制排序，则需要在创建TreeSet时，调用一个带参构造器，传入Comparator对象。并有该Comparator对象负责集合元素的排序逻辑，集合元素可以不必实现Comparable接口。下面具体演示一下这种用法： 12345678910111213141516171819202122232425public static void main(String[] args)&#123; Person p1 = new Person(); p1.age =20; Person p2 =new Person(); p2.age = 30; Comparator&lt;Person&gt; comparator = new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; //年龄越小的排在越后面 if(o1.age&lt;o2.age)&#123; return 1; &#125;else if(o1.age&gt;o2.age)&#123; return -1; &#125;else&#123; return 0; &#125; &#125; &#125;; TreeSet&lt;Person&gt; set = new TreeSet&lt;Person&gt;(comparator); set.add(p1); set.add(p2); System.out.println(set); &#125; 1[Person[age=30], Person[age=20]] 总结：无论使用自然排序还是定制排序，都可以通过自定义比较逻辑实现各种各样的排序方式。 下图总结一下List和Set的使用 二.Map接口Map用于保存具有映射关系的数据，Map里保存着两组数据：key和value，它们都可以使任何引用类型的数据，但key不能重复。所以通过指定的key就可以取出对应的value。 请注意！！！， Map 没有继承 Collection 接口 HashMap和HashTable TreeMap 小结：HashMap 非线程安全HashMap：基于哈希表实现。使用HashMap要求添加的键类明确定义了hashCode()和equals()[可以重写hashCode()和equals()]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子。 TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。 适用场景分析：HashMap和HashTable:HashMap去掉了HashTable的contains方法，但是加上了containsValue()和containsKey()方法。HashTable同步的，而HashMap是非同步的，效率上比HashTable要高。HashMap允许空键值，而HashTable不允许。 HashMap：适用于Map中插入、删除和定位元素。TreeMap：适用于按自然顺序或自定义顺序遍历键(key)。 线程安全集合类与非线程安全集合类LinkedList、ArrayList、HashSet是非线程安全的，Vector是线程安全的;HashMap是非线程安全的，HashTable是线程安全的;StringBuilder是非线程安全的，StringBuffer是线程安全的。 数据结构ArrayXxx:底层数据结构是数组，查询快，增删慢LinkedXxx:底层数据结构是链表，查询慢，增删快HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals()TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序","categories":[{"name":"-JavaSe","slug":"JavaSe","permalink":"https://yuanyu96.github.io/categories/JavaSe/"}],"tags":[]},{"title":"各种排序算法","slug":"各种排序算法","date":"2021-09-29T08:54:26.000Z","updated":"2021-09-29T09:48:10.375Z","comments":true,"path":"2021/09/29/各种排序算法/","link":"","permalink":"https://yuanyu96.github.io/2021/09/29/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"排序算法比较 时间复杂度为O(n²)的排序算法1.冒泡排序冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。 12345678910111213141516171819202122232425262728public class BubbleSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i &lt; arr.length; i++) &#123; // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 2.选择排序首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 1234567891011121314151617181920212223242526272829public class SelectionSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 总共要经过 N-1 轮比较 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; // 记录目前能找到的最小值元素的下标 min = j; &#125; &#125; // 将找到的最小值和i位置所在的值进行交换 if (i != min) &#123; int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; &#125; &#125; return arr; &#125;&#125; 3.插入排序将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 1234567891011121314151617181920212223242526272829public class InsertSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt; arr.length; i++) &#123; // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; // 存在比其小的数，插入 if (j != i) &#123; arr[j] = tmp; &#125; &#125; return arr; &#125;&#125; 时间复杂度为O(nlogn)的排序算法1.快速排序快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 步骤： 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 12345678910111213141516171819202122232425262728293031323334353637383940public class QuickSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return quickSort(arr, 0, arr.length - 1); &#125; private int[] quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr; &#125; private int partition(int[] arr, int left, int right) &#123; // 设定基准值（pivot） int pivot = left; int index = pivot + 1; for (int i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index - 1; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 2.堆排序堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 步骤： 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HeapSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0, len); &#125; return arr; &#125; private void buildMaxHeap(int[] arr, int len) &#123; for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) &#123; heapify(arr, i, len); &#125; &#125; private void heapify(int[] arr, int i, int len) &#123; int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest, len); &#125; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 3.希尔排序希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。 步骤： 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 123456789101112131415public static void shellSort(int[] arr) &#123; int length = arr.length; int temp; for (int step = length / 2; step &gt;= 1; step /= 2) &#123; for (int i = step; i &lt; length; i++) &#123; temp = arr[i]; int j = i - step; while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123; arr[j + step] = arr[j]; j -= step; &#125; arr[j + step] = temp; &#125; &#125;&#125; 4.归并排序归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代； 步骤： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MergeSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); if (arr.length &lt; 2) &#123; return arr; &#125; int middle = (int) Math.floor(arr.length / 2); int[] left = Arrays.copyOfRange(arr, 0, middle); int[] right = Arrays.copyOfRange(arr, middle, arr.length); return merge(sort(left), sort(right)); &#125; protected int[] merge(int[] left, int[] right) &#123; int[] result = new int[left.length + right.length]; int i = 0; while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if (left[0] &lt;= right[0]) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; else &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; &#125; while (left.length &gt; 0) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; while (right.length &gt; 0) &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; return result; &#125;&#125; 时间复杂度为O(n+m)的算法1.计数排序TODO","categories":[{"name":"-算法基础","slug":"算法基础","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"合并两个有序数组","slug":"合并两个有序数组-md","date":"2021-09-29T07:15:49.000Z","updated":"2021-09-29T07:53:43.995Z","comments":true,"path":"2021/09/29/合并两个有序数组-md/","link":"","permalink":"https://yuanyu96.github.io/2021/09/29/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-md/","excerpt":"","text":"给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 1234输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2： 1234输入：nums1 = [1], m = 1, nums2 = [], n = 0输出：[1]解释：需要合并 [1] 和 [] 。合并结果是 [1] 。 示例 3： 12345输入：nums1 = [0], m = 0, nums2 = [1], n = 1输出：[1]解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 提示： nums1.length == m + n nums2.length == n 0 &lt;= m, n &lt;= 200 1 &lt;= m + n &lt;= 200 -109 &lt;= nums1[i], nums2[j] &lt;= 109 进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？ 方法一：双指针法本题可以借助两个数组已经独立有序的性质，利用双指针分别指向两个数组，对比取到的较小值，这样指针总共移动 m+n 次 ，时间复杂度为O（m+n），需要建一个中间的数组，空间复杂度为O（m+n） 12345678910111213141516171819202122class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int[] sorted = new int[m+n]; int p1=0,p2=0;//双指针 int x;//中间值 while(p1&lt;m||p2&lt;n)&#123; if(p1==m)&#123; x=nums2[p2++]; &#125;else if(p2==n)&#123; x=nums1[p1++]; &#125;else if(nums1[p1]&lt;=nums2[p2])&#123; x=nums1[p1++]; &#125;else&#123; x=nums2[p2++]; &#125; sorted[p1+p2-1]=x; &#125; for(int i =0 ;i&lt;m+n;i++)&#123; nums1[i]=sorted[i]; &#125; &#125;&#125; 方法二：逆向双指针法方法二中，之所以要使用临时变量，是因为如果直接合并到数组nums1中，nums1中的元素可能在取出之前被覆盖，观察题目可知，nums1后半部分是空着的，可以直接覆盖而不受影响，因此可以让指针从后往前遍历，每次比较最大值放在nums1最后面。 1234567891011121314151617181920class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 &gt;= 0 || p2 &gt;= 0) &#123; if (p1 == -1) &#123; cur = nums2[p2--]; &#125; else if (p2 == -1) &#123; cur = nums1[p1--]; &#125; else if (nums1[p1] &gt; nums2[p2]) &#123; cur = nums1[p1--]; &#125; else &#123; cur = nums2[p2--]; &#125; nums1[tail--] = cur; &#125; &#125;&#125; 复杂度分析 时间复杂度：O(m+n)指针移动单调递减，最多移动 m+n 次，因此时间复杂度为 O(m+n)。 空间复杂度：O(1)直接对数组 nums1原地修改，不需要额外空间","categories":[{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"两数相加","slug":"两数相加-md","date":"2021-09-29T02:57:45.000Z","updated":"2021-09-29T07:57:42.613Z","comments":true,"path":"2021/09/29/两数相加-md/","link":"","permalink":"https://yuanyu96.github.io/2021/09/29/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-md/","excerpt":"","text":"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.示例 2： 输入：l1 = [0], l2 = [0]输出：[0]示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内0 &lt;= Node.val &lt;= 9题目数据保证列表表示的数字不含前导零 方法同时遍历两个链表，把每个遍历的节点值相加，保存进位的值下次相加使用，一个链表遍历到尾时，其节点值始终是0，直到两个链表都遍历到尾部结束。切记不要忘了最后一位进位值！ 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head=null; ListNode tail = null;//头尾节点 int x=0;//进位 int lv1,lv2=0; while(l1!=null||l2!=null)&#123; lv1 = l1!=null?l1.val:0; lv2 = l2!=null?l2.val:0; //第一次相加 if(head == null)&#123; head=tail= new ListNode((lv1+lv2)%10); &#125;else&#123;//后面相加 tail.next = new ListNode((lv1+lv2+x)%10); tail = tail.next; &#125; if(l1!=null)&#123; l1=l1.next; &#125; if(l2!=null)&#123; l2=l2.next; &#125; x = (lv1+lv2+x)/10; &#125; if(x!=0)&#123; tail.next = new ListNode(x); &#125; return head; &#125;&#125;","categories":[{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"两数之和","slug":"两数之和-md","date":"2021-09-28T10:34:42.000Z","updated":"2021-09-28T11:36:20.755Z","comments":true,"path":"2021/09/28/两数之和-md/","link":"","permalink":"https://yuanyu96.github.io/2021/09/28/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-md/","excerpt":"","text":"两数之和题目描述： 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。示例 2： 输入：nums = [3,2,4], target = 6输出：[1,2]示例 3： 输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104-109 &lt;= nums[i] &lt;= 109-109 &lt;= target &lt;= 109只会存在一个有效答案进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 方法一：暴力破解法 双层循环12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result=new int[2]; for(int i=0;i&lt;nums.length-1;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target)&#123; result = new int[]&#123;i,j&#125;; &#125; &#125; &#125; return result; &#125;&#125; 没啥好说的 时间复杂度O（n²），不建议 方法二：哈希表12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (hashtable.containsKey(target - nums[i])) &#123; return new int[]&#123;hashtable.get(target - nums[i]), i&#125;; &#125; hashtable.put(nums[i], i); &#125; return new int[0]; &#125;&#125; 时间复杂度O（n） map里面key存数组的值，value存数组下标，遍历的同时存入map，当遍历到key=target-nums[i]时就找到和为target的两数了","categories":[{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]}],"categories":[{"name":"-JavaSe","slug":"JavaSe","permalink":"https://yuanyu96.github.io/categories/JavaSe/"},{"name":"-算法基础","slug":"算法基础","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]}