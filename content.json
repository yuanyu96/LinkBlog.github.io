{"meta":{"title":"Y-Blog","subtitle":"","description":"记录点滴,热爱分享","author":"yuanyu","url":"https://yuanyu96.github.io","root":"/"},"pages":[{"title":"书单","date":"2021-09-28T08:08:01.685Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"books/index.html","permalink":"https://yuanyu96.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-09-28T10:26:16.820Z","updated":"2021-09-28T10:26:16.820Z","comments":true,"path":"categories/index.html","permalink":"https://yuanyu96.github.io/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-09-28T08:08:01.668Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"/404.html","permalink":"https://yuanyu96.github.io/404.html","excerpt":"","text":""},{"title":"标签","date":"2021-09-28T08:08:01.691Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"tags/index.html","permalink":"https://yuanyu96.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-09-28T09:40:22.003Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"about/index.html","permalink":"https://yuanyu96.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2021-09-28T08:08:01.687Z","updated":"2021-05-31T02:54:50.000Z","comments":true,"path":"links/index.html","permalink":"https://yuanyu96.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-09-28T08:08:01.689Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"repository/index.html","permalink":"https://yuanyu96.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"各种排序算法","slug":"各种排序算法","date":"2021-09-29T08:54:26.000Z","updated":"2021-09-29T09:48:10.375Z","comments":true,"path":"2021/09/29/各种排序算法/","link":"","permalink":"https://yuanyu96.github.io/2021/09/29/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"排序算法比较 时间复杂度为O(n²)的排序算法1.冒泡排序冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。 12345678910111213141516171819202122232425262728public class BubbleSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); for (int i = 1; i &lt; arr.length; i++) &#123; // 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。 boolean flag = true; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; return arr; &#125;&#125; 2.选择排序首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 1234567891011121314151617181920212223242526272829public class SelectionSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 总共要经过 N-1 轮比较 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int min = i; // 每轮需要比较的次数 N-i for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; // 记录目前能找到的最小值元素的下标 min = j; &#125; &#125; // 将找到的最小值和i位置所在的值进行交换 if (i != min) &#123; int tmp = arr[i]; arr[i] = arr[min]; arr[min] = tmp; &#125; &#125; return arr; &#125;&#125; 3.插入排序将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 1234567891011121314151617181920212223242526272829public class InsertSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的 for (int i = 1; i &lt; arr.length; i++) &#123; // 记录要插入的数据 int tmp = arr[i]; // 从已经排序的序列最右边的开始比较，找到比其小的数 int j = i; while (j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]) &#123; arr[j] = arr[j - 1]; j--; &#125; // 存在比其小的数，插入 if (j != i) &#123; arr[j] = tmp; &#125; &#125; return arr; &#125;&#125; 时间复杂度为O(nlogn)的排序算法1.快速排序快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。 快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。 步骤： 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 12345678910111213141516171819202122232425262728293031323334353637383940public class QuickSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return quickSort(arr, 0, arr.length - 1); &#125; private int[] quickSort(int[] arr, int left, int right) &#123; if (left &lt; right) &#123; int partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr; &#125; private int partition(int[] arr, int left, int right) &#123; // 设定基准值（pivot） int pivot = left; int index = pivot + 1; for (int i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index - 1; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 2.堆排序堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 步骤： 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HeapSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int len = arr.length; buildMaxHeap(arr, len); for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0, len); &#125; return arr; &#125; private void buildMaxHeap(int[] arr, int len) &#123; for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) &#123; heapify(arr, i, len); &#125; &#125; private void heapify(int[] arr, int i, int len) &#123; int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest, len); &#125; &#125; private void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 3.希尔排序希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率； 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位； 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。 步骤： 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 123456789101112131415public static void shellSort(int[] arr) &#123; int length = arr.length; int temp; for (int step = length / 2; step &gt;= 1; step /= 2) &#123; for (int i = step; i &lt; length; i++) &#123; temp = arr[i]; int j = i - step; while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) &#123; arr[j + step] = arr[j]; j -= step; &#125; arr[j + step] = temp; &#125; &#125;&#125; 4.归并排序归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代； 步骤： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MergeSort implements IArraySort &#123; @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); if (arr.length &lt; 2) &#123; return arr; &#125; int middle = (int) Math.floor(arr.length / 2); int[] left = Arrays.copyOfRange(arr, 0, middle); int[] right = Arrays.copyOfRange(arr, middle, arr.length); return merge(sort(left), sort(right)); &#125; protected int[] merge(int[] left, int[] right) &#123; int[] result = new int[left.length + right.length]; int i = 0; while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if (left[0] &lt;= right[0]) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; else &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; &#125; while (left.length &gt; 0) &#123; result[i++] = left[0]; left = Arrays.copyOfRange(left, 1, left.length); &#125; while (right.length &gt; 0) &#123; result[i++] = right[0]; right = Arrays.copyOfRange(right, 1, right.length); &#125; return result; &#125;&#125; 时间复杂度为O(n+m)的算法1.计数排序TODO","categories":[{"name":"-算法基础","slug":"算法基础","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"合并两个有序数组","slug":"合并两个有序数组-md","date":"2021-09-29T07:15:49.000Z","updated":"2021-09-29T07:53:43.995Z","comments":true,"path":"2021/09/29/合并两个有序数组-md/","link":"","permalink":"https://yuanyu96.github.io/2021/09/29/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-md/","excerpt":"","text":"给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 1234输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2： 1234输入：nums1 = [1], m = 1, nums2 = [], n = 0输出：[1]解释：需要合并 [1] 和 [] 。合并结果是 [1] 。 示例 3： 12345输入：nums1 = [0], m = 0, nums2 = [1], n = 1输出：[1]解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 提示： nums1.length == m + n nums2.length == n 0 &lt;= m, n &lt;= 200 1 &lt;= m + n &lt;= 200 -109 &lt;= nums1[i], nums2[j] &lt;= 109 进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？ 方法一：双指针法本题可以借助两个数组已经独立有序的性质，利用双指针分别指向两个数组，对比取到的较小值，这样指针总共移动 m+n 次 ，时间复杂度为O（m+n），需要建一个中间的数组，空间复杂度为O（m+n） 12345678910111213141516171819202122class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int[] sorted = new int[m+n]; int p1=0,p2=0;//双指针 int x;//中间值 while(p1&lt;m||p2&lt;n)&#123; if(p1==m)&#123; x=nums2[p2++]; &#125;else if(p2==n)&#123; x=nums1[p1++]; &#125;else if(nums1[p1]&lt;=nums2[p2])&#123; x=nums1[p1++]; &#125;else&#123; x=nums2[p2++]; &#125; sorted[p1+p2-1]=x; &#125; for(int i =0 ;i&lt;m+n;i++)&#123; nums1[i]=sorted[i]; &#125; &#125;&#125; 方法二：逆向双指针法方法二中，之所以要使用临时变量，是因为如果直接合并到数组nums1中，nums1中的元素可能在取出之前被覆盖，观察题目可知，nums1后半部分是空着的，可以直接覆盖而不受影响，因此可以让指针从后往前遍历，每次比较最大值放在nums1最后面。 1234567891011121314151617181920class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 &gt;= 0 || p2 &gt;= 0) &#123; if (p1 == -1) &#123; cur = nums2[p2--]; &#125; else if (p2 == -1) &#123; cur = nums1[p1--]; &#125; else if (nums1[p1] &gt; nums2[p2]) &#123; cur = nums1[p1--]; &#125; else &#123; cur = nums2[p2--]; &#125; nums1[tail--] = cur; &#125; &#125;&#125; 复杂度分析 时间复杂度：O(m+n)指针移动单调递减，最多移动 m+n 次，因此时间复杂度为 O(m+n)。 空间复杂度：O(1)直接对数组 nums1原地修改，不需要额外空间","categories":[{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"两数相加","slug":"两数相加-md","date":"2021-09-29T02:57:45.000Z","updated":"2021-09-29T07:57:42.613Z","comments":true,"path":"2021/09/29/两数相加-md/","link":"","permalink":"https://yuanyu96.github.io/2021/09/29/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-md/","excerpt":"","text":"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.示例 2： 输入：l1 = [0], l2 = [0]输出：[0]示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内0 &lt;= Node.val &lt;= 9题目数据保证列表表示的数字不含前导零 方法同时遍历两个链表，把每个遍历的节点值相加，保存进位的值下次相加使用，一个链表遍历到尾时，其节点值始终是0，直到两个链表都遍历到尾部结束。切记不要忘了最后一位进位值！ 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head=null; ListNode tail = null;//头尾节点 int x=0;//进位 int lv1,lv2=0; while(l1!=null||l2!=null)&#123; lv1 = l1!=null?l1.val:0; lv2 = l2!=null?l2.val:0; //第一次相加 if(head == null)&#123; head=tail= new ListNode((lv1+lv2)%10); &#125;else&#123;//后面相加 tail.next = new ListNode((lv1+lv2+x)%10); tail = tail.next; &#125; if(l1!=null)&#123; l1=l1.next; &#125; if(l2!=null)&#123; l2=l2.next; &#125; x = (lv1+lv2+x)/10; &#125; if(x!=0)&#123; tail.next = new ListNode(x); &#125; return head; &#125;&#125;","categories":[{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"两数之和","slug":"两数之和-md","date":"2021-09-28T10:34:42.000Z","updated":"2021-09-28T11:36:20.755Z","comments":true,"path":"2021/09/28/两数之和-md/","link":"","permalink":"https://yuanyu96.github.io/2021/09/28/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-md/","excerpt":"","text":"两数之和题目描述： 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。示例 2： 输入：nums = [3,2,4], target = 6输出：[1,2]示例 3： 输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104-109 &lt;= nums[i] &lt;= 109-109 &lt;= target &lt;= 109只会存在一个有效答案进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 方法一：暴力破解法 双层循环12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result=new int[2]; for(int i=0;i&lt;nums.length-1;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target)&#123; result = new int[]&#123;i,j&#125;; &#125; &#125; &#125; return result; &#125;&#125; 没啥好说的 时间复杂度O（n²），不建议 方法二：哈希表12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (hashtable.containsKey(target - nums[i])) &#123; return new int[]&#123;hashtable.get(target - nums[i]), i&#125;; &#125; hashtable.put(nums[i], i); &#125; return new int[0]; &#125;&#125; 时间复杂度O（n） map里面key存数组的值，value存数组下标，遍历的同时存入map，当遍历到key=target-nums[i]时就找到和为target的两数了","categories":[{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]}],"categories":[{"name":"-算法基础","slug":"算法基础","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]}