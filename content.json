{"meta":{"title":"LinkBlog","subtitle":"","description":"","author":"yuanyu","url":"https://yuanyu96.github.io","root":"/"},"pages":[{"title":"Repositories","date":"2021-09-28T08:08:01.689Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"repository/index.html","permalink":"https://yuanyu96.github.io/repository/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-09-28T08:08:01.668Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"/404.html","permalink":"https://yuanyu96.github.io/404.html","excerpt":"","text":""},{"title":"标签","date":"2021-09-28T08:08:01.691Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"tags/index.html","permalink":"https://yuanyu96.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-09-28T10:26:16.820Z","updated":"2021-09-28T10:26:16.820Z","comments":true,"path":"categories/index.html","permalink":"https://yuanyu96.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-09-28T09:40:22.003Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"about/index.html","permalink":"https://yuanyu96.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-09-28T08:08:01.685Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"books/index.html","permalink":"https://yuanyu96.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-09-28T08:08:01.687Z","updated":"2021-05-31T02:54:50.000Z","comments":true,"path":"links/index.html","permalink":"https://yuanyu96.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"合并两个有序数组","slug":"合并两个有序数组-md","date":"2021-09-29T07:15:49.000Z","updated":"2021-09-29T07:37:25.162Z","comments":true,"path":"2021/09/29/合并两个有序数组-md/","link":"","permalink":"https://yuanyu96.github.io/2021/09/29/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-md/","excerpt":"","text":"给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 1234输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2： 1234输入：nums1 = [1], m = 1, nums2 = [], n = 0输出：[1]解释：需要合并 [1] 和 [] 。合并结果是 [1] 。 示例 3： 12345输入：nums1 = [0], m = 0, nums2 = [1], n = 1输出：[1]解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 提示： nums1.length == m + n nums2.length == n 0 &lt;= m, n &lt;= 200 1 &lt;= m + n &lt;= 200 -109 &lt;= nums1[i], nums2[j] &lt;= 109 进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？ 方法一：双指针法本题可以借助两个数组已经独立有序的性质，利用双指针分别指向两个数组，对比取到的较小值，这样指针总共移动 m+n 次 ，时间复杂度为O（m+n），需要建一个中间的数组，空间复杂度为O（m+n） 12345678910111213141516171819202122class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int[] sorted = new int[m+n]; int p1=0,p2=0;//双指针 int x;//中间值 while(p1&lt;m||p2&lt;n)&#123; if(p1==m)&#123; x=nums2[p2++]; &#125;else if(p2==n)&#123; x=nums1[p1++]; &#125;else if(nums1[p1]&lt;=nums2[p2])&#123; x=nums1[p1++]; &#125;else&#123; x=nums2[p2++]; &#125; sorted[p1+p2-1]=x; &#125; for(int i =0 ;i&lt;m+n;i++)&#123; nums1[i]=sorted[i]; &#125; &#125;&#125; 方法二：逆向双指针法方法二中，之所以要使用临时变量，是因为如果直接合并到数组nums1中，nums1中的元素可能在取出之前被覆盖，观察题目可知，nums1后半部分是空着的，可以直接覆盖而不受影响，因此可以让指针从后往前遍历，每次比较最大值放在nums1最后面。 1234567891011121314151617181920class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 &gt;= 0 || p2 &gt;= 0) &#123; if (p1 == -1) &#123; cur = nums2[p2--]; &#125; else if (p2 == -1) &#123; cur = nums1[p1--]; &#125; else if (nums1[p1] &gt; nums2[p2]) &#123; cur = nums1[p1--]; &#125; else &#123; cur = nums2[p2--]; &#125; nums1[tail--] = cur; &#125; &#125;&#125; 复杂度分析 时间复杂度：O(m+n)指针移动单调递减，最多移动 m+n 次，因此时间复杂度为 O(m+n)。 空间复杂度：O(1)直接对数组 nums1原地修改，不需要额外空间","categories":[{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"两数相加","slug":"两数相加-md","date":"2021-09-29T02:57:45.000Z","updated":"2021-09-29T03:25:13.902Z","comments":true,"path":"2021/09/29/两数相加-md/","link":"","permalink":"https://yuanyu96.github.io/2021/09/29/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-md/","excerpt":"","text":"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.示例 2： 输入：l1 = [0], l2 = [0]输出：[0]示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内0 &lt;= Node.val &lt;= 9题目数据保证列表表示的数字不含前导零 方法同时遍历两个链表，把每个遍历的节点值相加，保存进位的值下次相加使用，一个链表遍历到尾时，其节点值始终是0，直到两个链表都遍历到尾部结束。切记不要忘了最后一位进位值！ 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head=null; ListNode tail = null;//头尾节点 int x=0;//进位 int lv1,lv2=0; while(l1!=null||l2!=null)&#123; lv1 = l1!=null?l1.val:0; lv2 = l2!=null?l2.val:0; //第一次相加 if(head == null)&#123; head=tail= new ListNode((lv1+lv2)%10); &#125;else&#123;//后面相加 tail.next = new ListNode((lv1+lv2+x)%10); tail = tail.next; &#125; if(l1!=null)&#123; l1=l1.next; &#125; if(l2!=null)&#123; l2=l2.next; &#125; x = (lv1+lv2+x)/10; &#125; if(x!=0)&#123; tail.next = new ListNode(x); &#125; return head; &#125;&#125;","categories":[{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"两数之和","slug":"两数之和-md","date":"2021-09-28T10:34:42.000Z","updated":"2021-09-28T11:36:20.755Z","comments":true,"path":"2021/09/28/两数之和-md/","link":"","permalink":"https://yuanyu96.github.io/2021/09/28/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-md/","excerpt":"","text":"两数之和题目描述： 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。示例 2： 输入：nums = [3,2,4], target = 6输出：[1,2]示例 3： 输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104-109 &lt;= nums[i] &lt;= 109-109 &lt;= target &lt;= 109只会存在一个有效答案进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 方法一：暴力破解法 双层循环12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result=new int[2]; for(int i=0;i&lt;nums.length-1;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target)&#123; result = new int[]&#123;i,j&#125;; &#125; &#125; &#125; return result; &#125;&#125; 没啥好说的 时间复杂度O（n²），不建议 方法二：哈希表12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (hashtable.containsKey(target - nums[i])) &#123; return new int[]&#123;hashtable.get(target - nums[i]), i&#125;; &#125; hashtable.put(nums[i], i); &#125; return new int[0]; &#125;&#125; 时间复杂度O（n） map里面key存数组的值，value存数组下标，遍历的同时存入map，当遍历到key=target-nums[i]时就找到和为target的两数了","categories":[{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-09-28T03:02:06.794Z","updated":"2021-09-28T10:45:55.347Z","comments":true,"path":"2021/09/28/hello-world/","link":"","permalink":"https://yuanyu96.github.io/2021/09/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello yuanyuQuick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"-hello","slug":"hello","permalink":"https://yuanyu96.github.io/categories/hello/"}],"tags":[]}],"categories":[{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"-hello","slug":"hello","permalink":"https://yuanyu96.github.io/categories/hello/"}],"tags":[]}