{"meta":{"title":"LinkBlog","subtitle":"","description":"","author":"yuanyu","url":"https://yuanyu96.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-09-28T08:08:01.668Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"/404.html","permalink":"https://yuanyu96.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2021-09-28T10:26:16.820Z","updated":"2021-09-28T10:26:16.820Z","comments":true,"path":"categories/index.html","permalink":"https://yuanyu96.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-09-28T09:40:22.003Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"about/index.html","permalink":"https://yuanyu96.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-09-28T08:08:01.685Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"books/index.html","permalink":"https://yuanyu96.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-09-28T08:08:01.687Z","updated":"2021-05-31T02:54:50.000Z","comments":true,"path":"links/index.html","permalink":"https://yuanyu96.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-09-28T08:08:01.691Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"tags/index.html","permalink":"https://yuanyu96.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-09-28T08:08:01.689Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"repository/index.html","permalink":"https://yuanyu96.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"两数相加","slug":"两数相加-md","date":"2021-09-29T02:57:45.000Z","updated":"2021-09-29T03:25:13.902Z","comments":true,"path":"2021/09/29/两数相加-md/","link":"","permalink":"https://yuanyu96.github.io/2021/09/29/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-md/","excerpt":"","text":"给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4]输出：[7,0,8]解释：342 + 465 = 807.示例 2： 输入：l1 = [0], l2 = [0]输出：[0]示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内0 &lt;= Node.val &lt;= 9题目数据保证列表表示的数字不含前导零 方法同时遍历两个链表，把每个遍历的节点值相加，保存进位的值下次相加使用，一个链表遍历到尾时，其节点值始终是0，直到两个链表都遍历到尾部结束。切记不要忘了最后一位进位值！ 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head=null; ListNode tail = null;//头尾节点 int x=0;//进位 int lv1,lv2=0; while(l1!=null||l2!=null)&#123; lv1 = l1!=null?l1.val:0; lv2 = l2!=null?l2.val:0; //第一次相加 if(head == null)&#123; head=tail= new ListNode((lv1+lv2)%10); &#125;else&#123;//后面相加 tail.next = new ListNode((lv1+lv2+x)%10); tail = tail.next; &#125; if(l1!=null)&#123; l1=l1.next; &#125; if(l2!=null)&#123; l2=l2.next; &#125; x = (lv1+lv2+x)/10; &#125; if(x!=0)&#123; tail.next = new ListNode(x); &#125; return head; &#125;&#125;","categories":[{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"两数之和","slug":"两数之和-md","date":"2021-09-28T10:34:42.000Z","updated":"2021-09-28T11:36:20.755Z","comments":true,"path":"2021/09/28/两数之和-md/","link":"","permalink":"https://yuanyu96.github.io/2021/09/28/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-md/","excerpt":"","text":"两数之和题目描述： 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。示例 2： 输入：nums = [3,2,4], target = 6输出：[1,2]示例 3： 输入：nums = [3,3], target = 6输出：[0,1] 提示： 2 &lt;= nums.length &lt;= 104-109 &lt;= nums[i] &lt;= 109-109 &lt;= target &lt;= 109只会存在一个有效答案进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 方法一：暴力破解法 双层循环12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result=new int[2]; for(int i=0;i&lt;nums.length-1;i++)&#123; for(int j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target)&#123; result = new int[]&#123;i,j&#125;; &#125; &#125; &#125; return result; &#125;&#125; 没啥好说的 时间复杂度O（n²），不建议 方法二：哈希表12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (hashtable.containsKey(target - nums[i])) &#123; return new int[]&#123;hashtable.get(target - nums[i]), i&#125;; &#125; hashtable.put(nums[i], i); &#125; return new int[0]; &#125;&#125; 时间复杂度O（n） map里面key存数组的值，value存数组下标，遍历的同时存入map，当遍历到key=target-nums[i]时就找到和为target的两数了","categories":[{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-09-28T03:02:06.794Z","updated":"2021-09-28T10:45:55.347Z","comments":true,"path":"2021/09/28/hello-world/","link":"","permalink":"https://yuanyu96.github.io/2021/09/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello yuanyuQuick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"-hello","slug":"hello","permalink":"https://yuanyu96.github.io/categories/hello/"}],"tags":[]}],"categories":[{"name":"-算法","slug":"算法","permalink":"https://yuanyu96.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"-hello","slug":"hello","permalink":"https://yuanyu96.github.io/categories/hello/"}],"tags":[]}